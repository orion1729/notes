

Insertion Sort :
將整個數列看成兩類，一類是「已排序」，另一類是「未排序」。
每次從「未排序」中取出第一個元素，然後從後面與「已排序」的元素作比較，
直到找到適當的位置後做插入的動作。

實作：遞增排序
從後面開始與「已排序」作比較時，一旦「已排序」的元素比當前元素大時，
兩個就交換位置，然後繼續與下一個「已排序」元素比較。

時間複雜度：O(n^2)
最佳：O(n)
空間複雜度：O(n) + O(1)  <- swap 使用 temp 時額外多一個


——


Selection Sort :
將數列分為兩類，「已排序」和「未排序」。
每一次從「未排序」的類別中找一個最小的元素，並將其替換到「已排序」的尾端。

時間複雜度：O(n^2)
最佳：O(n^2)
平均：O(n^2)
空間複雜度：O(n) + O(1)  <- 看 swap 是否使用多餘空間


——


Bubble Sort :
每一輪要將最大的元素換到最後面，交換方式為從數列的開頭開始，
前後兩個元素比較，若大小順序相反則交換兩個元素，然後一路比到最後面。

時間複雜度：O(n^2)
最佳：O(n^2)
平均：O(n^2)
空間複雜度：O(n) + O(1)  <- swap


——


Quick Sort :
1. 挑選其中一個成員作為 pivot
2. 將小於 pivot 的成員放到 pivot 左邊，大於的放在右邊（遞增排序）
3. 繼續對左邊、右邊兩個小數列進行 Quick Sort

實作方向：
1. 用 index 紀錄大於、小於的區分過程
	將 pivot 放置數列的最右邊，方便 scan 時不必一直移動 pivot 的位置。
	設置一個 index 指向最左邊的位置，是用來記錄「小於」子陣列的標示。
	從最左邊開始一個一個檢查是否小於 pivot，若小於則與 index 所指的成員交換位置，
	然後 index 往下一個位置加一，直到所有成員都 scan 完畢。
	最後再將 pivot 從最右邊換到 index 所指的位置，此位置就是兩個子陣列的區分點。